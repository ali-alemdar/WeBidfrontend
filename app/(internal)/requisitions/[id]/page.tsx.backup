"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import InternalPage from "../../../components/InternalPage";
import RequireRoles from "../../../components/RequireRoles";
import { apiDelete, apiGet, apiPost, apiPut, apiUpload } from "../../../lib/api";
import { getCurrentUser } from "../../../lib/authClient";
import RequisitionEditorTabs from "./RequisitionEditorTabs";
import RequisitionSupplierQuickAddModal from "./RequisitionSupplierQuickAddModal";
import RequisitionItemEditModal from "./RequisitionItemEditModal";
import RequisitionApprovalFormModal from "./RequisitionApprovalFormModal";
import RequisitionHeader from "./RequisitionHeader";

interface Props {
  params: { id: string };
}

export type TabKey = "request" | "items" | "final";

function isoDateInput(v: any) {
  if (!v) return "";
  try {
    const d = new Date(v);
    if (Number.isNaN(d.getTime())) return "";
    return d.toISOString().slice(0, 10);
  } catch {
    return "";
  }
}

function Modal({
  open,
  title,
  onClose,
  children,
  onPrint,
}: {
  open: boolean;
  title: string;
  onClose: () => void;
  children: any;
  onPrint?: () => void;
}) {
  if (!open) return null;
  return (
    <div
      style={{
        position: "fixed",
        inset: 0,
        background: "rgba(0,0,0,0.35)",
        display: "flex",
        justifyContent: "center",
        alignItems: "flex-start",
        padding: 16,
        zIndex: 50,
        overflowY: "auto",
      }}
    >
      <div
        className="card"
        style={{
          width: "min(900px, 100%)",
          boxShadow: "none",
        }}
        onClick={(e) => e.stopPropagation()}
      >
        <div style={{ display: "flex", gap: 8, justifyContent: "space-between", alignItems: "center" }}>
          <h3 style={{ marginTop: 0, marginBottom: 0 }}>{title}</h3>
          <div style={{ display: "flex", gap: 8 }}>
            {onPrint && (
              <button
                className="btn"
                type="button"
                onClick={onPrint}
              >
                Print
              </button>
            )}
            <button className="btn" onClick={onClose}>
              Close
            </button>
          </div>
        </div>
        <div style={{ marginTop: 12 }}>{children}</div>
      </div>
    </div>
  );
}

export default function RequisitionDetailPage({ params }: Props) {
  const router = useRouter();

  const user = getCurrentUser();
  const roles = ((user as any)?.roles || []) as string[];
  const userId = user?.id ? Number(user.id) : NaN;
  const isSysAdmin = roles.includes("SYS_ADMIN");
  const isOfficer = roles.includes("REQUISITION_OFFICER") || roles.includes("TENDERING_OFFICER") || isSysAdmin;
  const isManager = roles.includes("REQUISITION_MANAGER") || roles.includes("APPROVER") || isSysAdmin;
  const isRequesterOnly = roles.includes("REQUESTER") && !isOfficer && !isManager;

  const [tab, setTab] = useState<TabKey>("request");

  const [data, setData] = useState<any>(null);
  const [suppliers, setSuppliers] = useState<any[]>([]);
  const [departments, setDepartments] = useState<any[]>([]);
  const [uoms, setUoms] = useState<any[]>([]);
  const [itemCategories, setItemCategories] = useState<any[]>([]);

  const [disclaimerTemplates, setDisclaimerTemplates] = useState<any[]>([]);
  const [biddingTemplates, setBiddingTemplates] = useState<any[]>([]);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string>("");
  const [acting, setActing] = useState<string>("");

  const [lockStatus, setLockStatus] = useState<'NONE' | 'OWNED' | 'LOCKED'>('NONE');
  const [lockInfo, setLockInfo] = useState<any | null>(null);

  const [autoSaveState, setAutoSaveState] = useState<"idle" | "saving" | "saved" | "error">("idle");
  const suppressAutosaveRef = useRef(true);
  const autosaveTimerRef = useRef<any>(null);

  const [showSupplierModal, setShowSupplierModal] = useState(false);
  const [showApprovalFormModal, setShowApprovalFormModal] = useState(false);

  // Approval form (local wiring for now – no backend persistence yet)
  const [approvalComment, setApprovalComment] = useState<string>("");
  const [approvalSignatures, setApprovalSignatures] = useState<
    Record<string, { signed: boolean }>
  >({});
  const [approvalRawSignatures, setApprovalRawSignatures] = useState<any[]>([]);
  const [approvalLoading, setApprovalLoading] = useState(false);
  const [approvalError, setApprovalError] = useState<string>("");
  const approvalCommentRef = useRef<HTMLTextAreaElement | null>(null);
  const signatureCanvasRef = useRef<HTMLCanvasElement | null>(null);
  const isDrawingRef = useRef(false);
  const lastPointRef = useRef<{ x: number; y: number } | null>(null);
  // After printing, some browsers get into a weird state where typing
  // is blocked until the window loses/regains focus. This flag lets
  // us programmatically reset focus once on the next interaction.
  const approvalNeedsFocusResetRef = useRef(false);
  const APPROVAL_COMMENT_LIMIT = 3900;

  // After printing in a separate tab, when the user closes that tab
  // and this window/tab regains focus, some environments require an
  // extra click before inputs accept typing. We work around this by
  // auto-focusing the textarea once when the window/tab becomes active
  // again after a print.
  useEffect(() => {
    if (typeof window === "undefined") return;

    const tryRefocus = () => {
      if (!showApprovalFormModal) return;
      if (!approvalNeedsFocusResetRef.current) return;
      approvalNeedsFocusResetRef.current = false;
      const el = approvalCommentRef.current;
      if (!el) return;
      setTimeout(() => {
        el.focus();
      }, 0);
    };

    const handleWindowFocus = () => {
      tryRefocus();
    };

    const handleVisibility = () => {
      if (document.visibilityState === "visible") {
        tryRefocus();
      }
    };

    window.addEventListener("focus", handleWindowFocus);
    document.addEventListener("visibilitychange", handleVisibility);

    return () => {
      window.removeEventListener("focus", handleWindowFocus);
      document.removeEventListener("visibilitychange", handleVisibility);
    };
  }, [showApprovalFormModal]);


  // Requisition header/request fields
  const [title, setTitle] = useState("");
  const [requestingDepartment, setRequestingDepartment] = useState("");
  const [purpose, setPurpose] = useState<"Budgeting" | "Bidding" | "">("");
  const [targetTimeline, setTargetTimeline] = useState<string>("");
  const [ledgerCategory, setLedgerCategory] = useState<string>("");
  const [description, setDescription] = useState("");

  // Disclaimer shown in final form before sending invitations
  const [disclaimerText, setDisclaimerText] = useState<string>(
    "For market price discovery only – no purchase commitment."
  );

  const getCanvasCoords = (event: any) => {
    const canvas = signatureCanvasRef.current;
    if (!canvas) return null;
    const rect = canvas.getBoundingClientRect();

    let clientX: number | null = null;
    let clientY: number | null = null;

    if (event.touches && event.touches[0]) {
      clientX = event.touches[0].clientX;
      clientY = event.touches[0].clientY;
    } else if (event.changedTouches && event.changedTouches[0]) {
      clientX = event.changedTouches[0].clientX;
      clientY = event.changedTouches[0].clientY;
    } else if (typeof event.clientX === "number" && typeof event.clientY === "number") {
      clientX = event.clientX;
      clientY = event.clientY;
    }

    if (clientX == null || clientY == null) return null;

    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY,
    };
  };

  const handleSignaturePointerDown = (event: any) => {
    if (!signatureCanvasRef.current) return;
    const pt = getCanvasCoords(event);
    if (!pt) return;
    event.preventDefault?.();

    const ctx = signatureCanvasRef.current.getContext("2d");
    if (!ctx) return;

    isDrawingRef.current = true;
    lastPointRef.current = pt;

    ctx.strokeStyle = "#111827"; // near black
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(pt.x, pt.y);
  };

  const handleSignaturePointerMove = (event: any) => {
    if (!isDrawingRef.current || !signatureCanvasRef.current) return;
    const pt = getCanvasCoords(event);
    if (!pt) return;
    event.preventDefault?.();

    const ctx = signatureCanvasRef.current.getContext("2d");
    if (!ctx) return;

    const last = lastPointRef.current || pt;
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ctx.lineTo(pt.x, pt.y);
    ctx.stroke();

    lastPointRef.current = pt;
  };

  const handleSignaturePointerUp = () => {
    isDrawingRef.current = false;
    lastPointRef.current = null;
  };

  const clearSignatureCanvas = () => {
    const canvas = signatureCanvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  const UOM_FALLBACK = [
    "EA",
    "SET",
    "LOT",
    "BOX",
    "KG",
    "G",
    "L",
    "ML",
    "M",
    "M2",
    "M3",
    "HR",
    "DAY",
    "MONTH",
  ];

  const UOM_OPTIONS = (Array.isArray(uoms) && uoms.length ? uoms : UOM_FALLBACK.map((c) => ({ code: c }))).map(
    (x: any) => String(x?.code || x || "").trim()
  ).filter(Boolean);

  // Items add fields
  const [itemType, setItemType] = useState<"MATERIAL" | "SERVICE">("MATERIAL");
  const [itemCategoryId, setItemCategoryId] = useState<string>("");
  const [itemName, setItemName] = useState("");
  const [itemTech, setItemTech] = useState("");
  const [itemUom, setItemUom] = useState("EA");
  const [itemQty, setItemQty] = useState<number>(1);
  const [itemAssumptions, setItemAssumptions] = useState<string>("");
  const [itemStandards, setItemStandards] = useState<string>("");

  // Item edit modal
  const [editingItem, setEditingItem] = useState<any>(null);
  const [editType, setEditType] = useState<"MATERIAL" | "SERVICE">("MATERIAL");
  const [editCategoryId, setEditCategoryId] = useState<string>("");
  const [editName, setEditName] = useState("");
  const [editTech, setEditTech] = useState("");
  const [editUom, setEditUom] = useState("EA");
  const [editQty, setEditQty] = useState<number>(1);
  const [editAssumptions, setEditAssumptions] = useState<string>("");
  const [editStandards, setEditStandards] = useState<string>("");

  // Invitations
  const [supplierSearch, setSupplierSearch] = useState("");
  const [selectedSupplierIds, setSelectedSupplierIds] = useState<Record<number, boolean>>({});

  // Supplier quick-add (modal)
  const [newSupplierName, setNewSupplierName] = useState("");
  const [newSupplierEmail, setNewSupplierEmail] = useState("");
  const [newSupplierPhone, setNewSupplierPhone] = useState("");

  const handlePrintApprovalForm = async () => {
    if (typeof window === "undefined") return;
    if (!data?.id) return;

    // Mark that after printing we may need to reset focus once on
    // the textarea to work around browser input quirks.
    approvalNeedsFocusResetRef.current = true;

    // Best-effort: persist latest comment before printing so
    // the print page reflects what the user sees, even if
    // the textarea has not lost focus yet.
    try {
      setApprovalError("");
      await apiPost(`/requisitions/${data.id}/approval-form/comment`, {
        comment: approvalComment || null,
      });
    } catch (e: any) {
      // Do not block printing on save errors; they will still
      // be visible in the main modal.
      setApprovalError(e?.message || "Failed to save comment before printing");
    }

    window.open(`/requisitions/${data.id}/approval-print`, "_blank");
  };

  const items: any[] = Array.isArray(data?.items) ? data.items : [];
  const invitations: any[] = Array.isArray(data?.invitations) ? data.invitations : [];

  const load = async () => {
    setError("");
    setLoading(true);
    suppressAutosaveRef.current = true;
    try {
      // Always load requisition + dropdown master data (departments, categories, UOM)
      const calls: Promise<any>[] = [
        apiGet(`/requisitions/${params.id}`),
        apiGet("/departments"),
        apiGet("/uom"),
        apiGet("/item-categories"),
      ];

      // Only officers/sysadmin need suppliers + templates for invitations and final form.
      const canEditMasterData = !isRequesterOnly && isOfficer;

      if (canEditMasterData) {
        calls.push(
          apiGet("/suppliers"),
          apiGet("/templates?type=DISCLAIMER"),
          apiGet("/templates?type=BIDDING_FORM"),
        );
      }

      const res = await Promise.all(calls);
      const r = res[0];
      const d = res[1];
      const u = res[2];
      const c = res[3];
      const s = canEditMasterData ? res[4] : [];
      const discT = canEditMasterData ? res[5] : [];
      const bidT = canEditMasterData ? res[6] : [];

      setData(r);

      // After invitations are sent, requisition becomes read-only and is shown on a separate page.
      const lockedStatuses = [
        // After real invitations are sent, edits require change control (read-only page)
        "INVITATIONS_SENT",
        "CHANGES_SUBMITTED",
        "REQUISITION_REJECTED",
        "PRICES_RECEIVED",
        "PRICES_REVIEWED",
        "REFERENCE_PRICE_CALCULATED",
        "BIDDING_FORM_PREPARED",
        "TENDER_READY",
      ];
      if (!isRequesterOnly && lockedStatuses.includes(String(r?.status || ""))) {
        router.replace(`/requisitions/${params.id}/view`);
        return;
      }

      setSuppliers(Array.isArray(s) ? s : []);
      setDepartments(Array.isArray(d) ? d : []);
      setUoms(Array.isArray(u) ? u : []);
      setItemCategories(Array.isArray(c) ? c : []);

      setDisclaimerTemplates(Array.isArray(discT) ? discT : []);
      setBiddingTemplates(Array.isArray(bidT) ? bidT : []);

      setTitle(r?.title || "");
      setRequestingDepartment(r?.requestingDepartment || "");
      setPurpose(r?.purpose || "");
      setTargetTimeline(r?.targetTimeline ? String(r.targetTimeline).slice(0, 10) : "");
      setLedgerCategory(r?.ledgerCategory || "");
      setDescription(r?.description || "");

      // If requisition already has a disclaimer, keep it.
      // Otherwise use the first active disclaimer template, then fallback string.
      if (!isRequesterOnly) {
        const discList = Array.isArray(discT) ? discT : [];
        const firstDisc = discList.find((x: any) => x?.isActive !== false);
        setDisclaimerText(
          r?.disclaimerText ||
            firstDisc?.content ||
            "For market price discovery only – no purchase commitment.",
        );
      }
      setAutoSaveState("idle");
    } catch (e: any) {
      setError(e?.message || "Failed to load requisition");
    } finally {
      setLoading(false);
      // Allow autosave for user edits after initial hydration.
      setTimeout(() => {
        suppressAutosaveRef.current = false;
      }, 0);
    }
  };

  // Initial load for officers/managers: acquire page-level lock on the server
  // and hydrate requisition data in a single backend-driven step.
  useEffect(() => {
    const loadWithEditContext = async () => {
      setError("");
      setLoading(true);
      suppressAutosaveRef.current = true;
      try {
        const calls: Promise<any>[] = [
          apiGet(`/requisitions/${params.id}/edit`),
          apiGet("/departments"),
          apiGet("/uom"),
          apiGet("/item-categories"),
        ];

        const canEditMasterData = !isRequesterOnly && isOfficer;
        if (canEditMasterData) {
          calls.push(
            apiGet("/suppliers"),
            apiGet("/templates?type=DISCLAIMER"),
            apiGet("/templates?type=BIDDING_FORM"),
          );
        }

        const res = await Promise.all(calls);
        const editCtx = res[0] as any;
        const r = editCtx?.requisition ?? editCtx;
        const d = res[1];
        const u = res[2];
        const c = res[3];
        const s = canEditMasterData ? res[4] : [];
        const discT = canEditMasterData ? res[5] : [];
        const bidT = canEditMasterData ? res[6] : [];

        setLockStatus(editCtx?.lockStatus ?? 'NONE');
        setLockInfo(editCtx?.lockInfo ?? null);
        setData(r);

        const lockedStatuses = [
          "INVITATIONS_SENT",
          "CHANGES_SUBMITTED",
          "REQUISITION_REJECTED",
          "PRICES_RECEIVED",
          "PRICES_REVIEWED",
          "REFERENCE_PRICE_CALCULATED",
          "BIDDING_FORM_PREPARED",
          "TENDER_READY",
        ];
        if (!isRequesterOnly && lockedStatuses.includes(String(r?.status || ""))) {
          router.replace(`/requisitions/${params.id}/view`);
          return;
        }

        setSuppliers(Array.isArray(s) ? s : []);
        setDepartments(Array.isArray(d) ? d : []);
        setUoms(Array.isArray(u) ? u : []);
        setItemCategories(Array.isArray(c) ? c : []);

        setDisclaimerTemplates(Array.isArray(discT) ? discT : []);
        setBiddingTemplates(Array.isArray(bidT) ? bidT : []);

        setTitle(r?.title || "");
        setRequestingDepartment(r?.requestingDepartment || "");
        setPurpose(r?.purpose || "");
        setTargetTimeline(
          r?.targetTimeline ? String(r.targetTimeline).slice(0, 10) : "",
        );
        setLedgerCategory(r?.ledgerCategory || "");
        setDescription(r?.description || "");

        if (!isRequesterOnly) {
          const discList = Array.isArray(discT) ? discT : [];
          const firstDisc = discList.find((x: any) => x?.isActive !== false);
          setDisclaimerText(
            r?.disclaimerText ||
              firstDisc?.content ||
              "For market price discovery only – no purchase commitment.",
          );
        }
        setAutoSaveState("idle");
      } catch (e: any) {
        setError(e?.message || "Failed to load requisition");
      } finally {
        setLoading(false);
        setTimeout(() => {
          suppressAutosaveRef.current = false;
        }, 0);
      }
    };

    loadWithEditContext();

    // Best-effort release on unmount, mirroring tender prep behaviour.
    return () => {
      apiPost(`/requisitions/${params.id}/edit-release`, {}).catch(() => {});
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params.id]);

  const doAction = async (name: string, fn: () => Promise<any>) => {
    setError("");
    setActing(name);
    try {
      await fn();
      await load();
    } catch (e: any) {
      setError(e?.message || "Action failed");
    } finally {
      setActing("");
    }
  };

  const canRequesterEdit = isRequesterOnly && String(data?.status || "") === "DRAFT";
  const coreCanEdit = !isRequesterOnly || canRequesterEdit;
  const isLockedByAnother = lockStatus === 'LOCKED';
  const canEdit = coreCanEdit && !isLockedByAnother;

  const saveAll = async () => {
    if (!data?.id) return;
    if (!canEdit) return;
    setAutoSaveState("saving");
    try {
      await apiPut(`/requisitions/${data.id}`, {
        title,
        requestingDepartment,
        purpose,
        targetTimeline: targetTimeline || null,
        ledgerCategory: ledgerCategory || null,
        description,
        disclaimerText,
      });
      setAutoSaveState("saved");
    } catch (e: any) {
      setAutoSaveState("error");
      setError(e?.message || "Failed to save");
    }
  };

  // Autosave (debounced) for request fields and disclaimer.
  useEffect(() => {
    if (!data?.id) return;
    if (loading) return;
    if (acting !== "") return;
    if (!canEdit) return;
    if (lockStatus === 'LOCKED') return;
    if (suppressAutosaveRef.current) return;

    if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
    autosaveTimerRef.current = setTimeout(() => {
      saveAll();
    }, 900);

    return () => {
      if (autosaveTimerRef.current) clearTimeout(autosaveTimerRef.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [title, requestingDepartment, purpose, targetTimeline, ledgerCategory, description, disclaimerText]);

  const submitRequesterDraft = () =>
    doAction("submitRequesterDraft", async () => {
      await apiPost(`/requisitions/${data.id}/requester-submit`, {});
      router.replace("/requisitions/status");
    });

  const requesterResubmit = () =>
    doAction("requesterResubmit", async () => {
      const fresh = await apiPost(`/requisitions/${data.id}/requester-resubmit`, {});
      // Open the new draft so requester can edit it.
      router.replace(`/requisitions/${fresh.id}`);
    });

  const sendInvitations = (supplierIds: number[]) =>
    doAction("sendInvitations", async () => {
      // Basic client-side validations before hitting the API.
      const itemCount = Array.isArray(items) ? items.length : 0;
      if (itemCount === 0) {
        throw new Error("Add at least one item before sending invitations");
      }

      if (supplierIds.length === 0) {
        throw new Error("Select at least one supplier before sending invitations");
      }

      const allSuppliers = Array.isArray(suppliers) ? suppliers : [];
      const selectedWithDetails = supplierIds
        .map((id) => allSuppliers.find((s: any) => Number(s.id) === id))
        .filter(Boolean) as any[];

      const missingEmailNames = selectedWithDetails
        .filter((s) => !String(s.email || "").trim())
        .map((s) => String(s.name || s.id));

      if (missingEmailNames.length > 0) {
        const sample = missingEmailNames.slice(0, 3).join(", ");
        const more = missingEmailNames.length > 3 ? ` …(+${missingEmailNames.length - 3} more)` : "";
        throw new Error(
          `All selected suppliers must have an email address to receive invitations. Missing email for: ${sample}${more}`,
        );
      }

      await apiPost(`/requisitions/${data.id}/invitations/send`, { supplierIds });
      setSelectedSupplierIds({});
      router.push(`/requisitions/${data.id}/view`);
    });

  const startManualSubmissions = () => {
    router.push(`/requisitions/${data.id}/manual-submissions`);
  };


  const addSupplierQuick = () =>
    doAction("addSupplier", async () => {
      if (!newSupplierName.trim()) throw new Error("Supplier name is required");
      await apiPost("/suppliers", {
        name: newSupplierName,
        email: newSupplierEmail || null,
        phone: newSupplierPhone || null,
      });
      setNewSupplierName("");
      setNewSupplierEmail("");
      setNewSupplierPhone("");
      setShowSupplierModal(false);
    });

  const openApprovalFormPage = () => {
    if (!data?.id) return;
    router.push(`/requisitions/${data.id}/approval`);
  };

  const openEditItem = (it: any) => {
    setEditingItem(it);
    setEditType((it?.itemType || "MATERIAL") as any);
    setEditCategoryId(it?.itemCategoryId != null ? String(it.itemCategoryId) : "");
    setEditName(it?.name || "");
    setEditTech(it?.technicalDescription || "");
    setEditUom(it?.uom || "EA");
    setEditQty(Number(it?.quantity ?? 1));
    setEditAssumptions(it?.assumptionsExclusions || "");
    setEditStandards(it?.requiredStandards || "");
  };

  const saveEditItem = () =>
    doAction("saveItem", async () => {
      if (!editingItem?.id) return;
      await apiPut(`/requisitions/${data.id}/items/${editingItem.id}`, {
        itemType: editType,
        itemCategoryId: editCategoryId || null,
        name: editName,
        technicalDescription: editTech,
        uom: editUom,
        quantity: editQty,
        assumptionsExclusions: editAssumptions || null,
        requiredStandards: editStandards || null,
      });
      setEditingItem(null);
    });

  if (loading && !data) {
    return (
      <RequireRoles anyOf={["REQUESTER", "REQUISITION_OFFICER", "REQUISITION_MANAGER", "TENDERING_OFFICER", "TENDER_APPROVAL", "SYS_ADMIN"]} title={`Requisition ${params.id}`}>
        <InternalPage title={`Requisition ${params.id}`}>
          <p>Loading…</p>
        </InternalPage>
      </RequireRoles>
    );
  }

  if (!data) {
    return (
      <RequireRoles anyOf={["REQUESTER", "REQUISITION_OFFICER", "REQUISITION_MANAGER", "TENDERING_OFFICER", "TENDER_APPROVAL", "SYS_ADMIN"]} title={`Requisition ${params.id}`}>
        <InternalPage title={`Requisition ${params.id}`}>
          {error ? <p style={{ color: "#b91c1c" }}>{error}</p> : <p>Not found.</p>}
        </InternalPage>
      </RequireRoles>
    );
  }

  // If requisition uses manual submissions, redirect directly to the manual submissions form.
  if (data?.manualSubmissions) {
    if (typeof window !== "undefined") {
      window.location.replace(`/requisitions/${data.id}/manual-submissions`);
    }
    return (
      <RequireRoles
        anyOf={[
          "REQUESTER",
          "REQUISITION_OFFICER",
          "REQUISITION_MANAGER",
          "TENDERING_OFFICER",
          "TENDER_APPROVAL",
          "SYS_ADMIN",
        ]}
        title={`Requisition ${data.id}`}
      >
        <InternalPage title={`Requisition ${data.id}`}>
          <p>Redirecting to manual submissions…</p>
        </InternalPage>
      </RequireRoles>
    );
  }

  return (
    <RequireRoles
      anyOf={[
        "REQUESTER",
        "REQUISITION_OFFICER",
        "REQUISITION_MANAGER",
        "TENDERING_OFFICER",
        "TENDER_APPROVAL",
        "SYS_ADMIN",
      ]}
      title={`Requisition ${data.id}`}
    >
      <InternalPage title={`Requisition ${data.id}`}>
        {lockStatus === 'LOCKED' && (
          <div
            className="card"
            style={{
              boxShadow: 'none',
              marginBottom: 12,
              background: 'rgba(254,240,138,0.6)',
              border: '1px solid #facc15',
            }}
          >
            <div style={{ fontWeight: 800, marginBottom: 4 }}>
              Requisition locked
            </div>
            <div style={{ fontSize: 13 }}>
              This requisition is currently being edited by{' '}
              {lockInfo?.byUser?.fullName || 'another officer'}. You can view but not
              edit until they close it or the lock expires.
            </div>
          </div>
        )}

        <RequisitionHeader
          data={data}
          error={error}
          autoSaveState={autoSaveState}
          isRequesterOnly={isRequesterOnly}
          canRequesterEdit={canRequesterEdit}
          acting={acting}
          onSubmitRequesterDraft={submitRequesterDraft}
          onRequesterResubmit={requesterResubmit}
          onOpenApprovalForm={openApprovalFormPage}
        />

        <RequisitionEditorTabs
          tab={tab}
          setTab={setTab}
          isRequesterOnly={isRequesterOnly}
          canEdit={canEdit}
          data={data}
          departments={departments}
          itemCategories={itemCategories}
          UOM_OPTIONS={UOM_OPTIONS}
          items={items}
          invitations={invitations}
          disclaimerTemplates={disclaimerTemplates}
          biddingTemplates={biddingTemplates}
          disclaimerText={disclaimerText}
          setDisclaimerText={setDisclaimerText}
          suppliers={suppliers}
          supplierSearch={supplierSearch}
          setSupplierSearch={setSupplierSearch}
          selectedSupplierIds={selectedSupplierIds}
          setSelectedSupplierIds={setSelectedSupplierIds}
          sendInvitations={sendInvitations}
          startManualSubmissions={startManualSubmissions}
          setShowSupplierModal={setShowSupplierModal}
          acting={acting}
          title={title}
          setTitle={setTitle}
          requestingDepartment={requestingDepartment}
          setRequestingDepartment={setRequestingDepartment}
          purpose={purpose}
          setPurpose={setPurpose}
          targetTimeline={targetTimeline}
          setTargetTimeline={setTargetTimeline}
          ledgerCategory={ledgerCategory}
          setLedgerCategory={setLedgerCategory}
          description={description}
          setDescription={setDescription}
          itemType={itemType}
          setItemType={setItemType}
          itemCategoryId={itemCategoryId}
          setItemCategoryId={setItemCategoryId}
          itemName={itemName}
          setItemName={setItemName}
          itemTech={itemTech}
          setItemTech={setItemTech}
          itemUom={itemUom}
          setItemUom={setItemUom}
          itemQty={itemQty}
          setItemQty={setItemQty}
          itemAssumptions={itemAssumptions}
          setItemAssumptions={setItemAssumptions}
          itemStandards={itemStandards}
          setItemStandards={setItemStandards}
          openEditItem={openEditItem}
          doAction={doAction}
          load={load}
          isoDateInput={isoDateInput}
        />

        <Modal
          open={showApprovalFormModal}
          title="Requisition approval form"
          onClose={() => setShowApprovalFormModal(false)}
          onPrint={handlePrintApprovalForm}
        >
          <RequisitionApprovalFormModal
            open={showApprovalFormModal}
            onClose={() => setShowApprovalFormModal(false)}
            onPrint={handlePrintApprovalForm}
            data={data}
            items={items}
            userId={userId}
            isOfficer={isOfficer}
            isManager={isManager}
            approvalComment={approvalComment}
            setApprovalComment={setApprovalComment}
            approvalCommentRef={approvalCommentRef}
            approvalError={approvalError}
            setApprovalError={setApprovalError}
            approvalSignatures={approvalSignatures}
            setApprovalSignatures={setApprovalSignatures}
            approvalRawSignatures={approvalRawSignatures}
            setApprovalRawSignatures={setApprovalRawSignatures}
          approvalLoading={approvalLoading}
          setApprovalLoading={setApprovalLoading}
          APPROVAL_COMMENT_LIMIT={APPROVAL_COMMENT_LIMIT}
          signatureCanvasRef={signatureCanvasRef}
          clearSignatureCanvas={clearSignatureCanvas}
          handleSignaturePointerDown={handleSignaturePointerDown}
          handleSignaturePointerMove={handleSignaturePointerMove}
          handleSignaturePointerUp={handleSignaturePointerUp}
        />
        </Modal>

        <Modal
          open={showSupplierModal}
          title="Manage suppliers (quick add)"
          onClose={() => setShowSupplierModal(false)}
        >
          <RequisitionSupplierQuickAddModal
            acting={acting}
            newSupplierName={newSupplierName}
            setNewSupplierName={setNewSupplierName}
            newSupplierEmail={newSupplierEmail}
            setNewSupplierEmail={setNewSupplierEmail}
            newSupplierPhone={newSupplierPhone}
            setNewSupplierPhone={setNewSupplierPhone}
            addSupplierQuick={addSupplierQuick}
            onClose={() => setShowSupplierModal(false)}
          />
        </Modal>

        <Modal
          open={!!editingItem}
          title={`${canEdit ? "Edit" : "View"} item ${editingItem?.itemNo ?? editingItem?.id ?? ""}`}
          onClose={() => setEditingItem(null)}
        >
          <RequisitionItemEditModal
            open={!!editingItem}
            canEdit={canEdit}
            UOM_OPTIONS={UOM_OPTIONS}
            itemCategories={itemCategories}
            acting={acting}
            editingItem={editingItem}
            setEditingItem={setEditingItem}
            editName={editName}
            setEditName={setEditName}
            editType={editType}
            setEditType={setEditType}
            editCategoryId={editCategoryId}
            setEditCategoryId={setEditCategoryId}
            editTech={editTech}
            setEditTech={setEditTech}
            editUom={editUom}
            setEditUom={setEditUom}
            editQty={editQty}
            setEditQty={setEditQty}
            editAssumptions={editAssumptions}
            setEditAssumptions={setEditAssumptions}
            editStandards={editStandards}
            setEditStandards={setEditStandards}
            saveEditItem={saveEditItem}
            deleteItem={() => {
              if (!editingItem?.id) return;
              if (!confirm("Delete this item?")) return;
              doAction("deleteItem", async () => {
                await apiDelete(`/requisitions/${data.id}/items/${editingItem.id}`);
                setEditingItem(null);
              });
            }}
          />
        </Modal>
      </InternalPage>
    </RequireRoles>
  );
}
